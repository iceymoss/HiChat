# ============================================================================
# GitOps CI/CD Pipeline 配置
# ============================================================================
# 完整工作流程：
# 1. 开发者推送代码到 master 分支
# 2. GitLab 触发 Pipeline（检测到 .gitlab-ci.yml）
# 3. Stage 1 (build): 构建 Docker 镜像并推送到 Registry
# 4. Stage 2 (update-config): 更新 k8s-config 分支的配置文件
# 5. ArgoCD 检测到 k8s-config 分支变化（轮询或 Webhook）
# 6. ArgoCD 自动同步到 Kubernetes 集群
# 7. Kubernetes 执行滚动更新，新版本运行
# ============================================================================

stages:
  - build          # 阶段 1: 构建并推送 Docker 镜像到 Registry
  - update-config  # 阶段 2: 更新配置分支 + 触发 ArgoCD 自动部署

# ============================================================================
# 全局变量配置
# ============================================================================
variables:
  # Docker 配置
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""  # 禁用 TLS（本地 Registry 使用 HTTP）

  # Docker Hub 配置
  DOCKERHUB_REGISTRY: "docker.io"
  DOCKERHUB_REPOSITORY: "$DOCKERHUB_USERNAME/hichat"

  # 镜像标签策略（Docker Hub）
  DOCKERHUB_IMAGE_BASE: "$DOCKERHUB_REGISTRY/$DOCKERHUB_REPOSITORY"
  IMAGE_TAG: $DOCKERHUB_IMAGE_BASE:$CI_COMMIT_REF_SLUG
  IMAGE_TAG_LATEST: $DOCKERHUB_IMAGE_BASE:latest
  IMAGE_TAG_COMMIT: $DOCKERHUB_IMAGE_BASE:$CI_COMMIT_SHORT_SHA

# ============================================================================
# Stage 1: 构建并推送 Docker 镜像
# ============================================================================
# 作用：将源代码构建成 Docker 镜像并推送到 GitLab Container Registry
# 流程位置：开发者推送代码 → GitLab 触发 Pipeline → build 阶段执行
# 输出：Registry 中的三个镜像标签（分支名、latest、commit SHA）
# 下一步：build 成功后触发 update-config 阶段
# ============================================================================
build:
  stage: build
  image: docker:24  # 使用 Docker 官方镜像作为执行环境
  
  # Docker-in-Docker 服务：在容器内运行 Docker daemon
  services:
    - name: docker:24-dind
      command: ["--insecure-registry=gitlab.iceymoss:5050"]  # 配置本地 Registry 为不安全模式
  
  before_script:
    # 登录 Docker Hub（在 GitLab CI 变量中配置 DOCKERHUB_USERNAME/DOCKERHUB_PASSWORD）
    - echo "$DOCKERHUB_PASSWORD" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin $DOCKERHUB_REGISTRY
  
  script:
    # 步骤 1: 构建 Docker 镜像（使用 Dockerfile 多阶段构建）
    - docker build -t $IMAGE_TAG -t $IMAGE_TAG_LATEST -t $IMAGE_TAG_COMMIT .
    
    # 步骤 2: 推送镜像到 Registry（三个标签）
    # - 分支名标签：用于标识分支（如 master, develop）
    # - latest 标签：最新版本（向后兼容）
    # - commit SHA 标签：精确版本（用于部署，可追溯）
    - docker push $IMAGE_TAG
    - docker push $IMAGE_TAG_LATEST
    - docker push $IMAGE_TAG_COMMIT
  
  # 触发条件：只在指定分支或合并请求时执行
  only:
    - main
    - master      # 主分支：生产环境部署
    - develop     # 开发分支：开发环境部署
    - merge_requests  # 合并请求：代码审查时构建
  
  # 使用带有 docker 标签的 Runner（支持 Docker-in-Docker）
  tags:
    - docker

# ============================================================================
# Stage 2: 更新 Kubernetes 配置（配置分支方案）
# ============================================================================
# 作用：更新 k8s-config 分支的配置文件，触发 ArgoCD 自动部署
# 流程位置：build 成功 → update-config 执行 → 推送到 k8s-config 分支 → ArgoCD 检测变化
# 关键点：
#   - 配置更新在 k8s-config 分支，不在 master 分支（保持 master 分支 Git 历史干净）
#   - 使用 commit SHA 作为镜像标签（精确版本，可追溯）
#   - 使用 [skip ci] 避免循环触发 Pipeline
# 下一步：ArgoCD 检测到 k8s-config 分支变化后自动同步到 Kubernetes 集群
# ============================================================================
update-config:
  stage: update-config
  image: ubuntu:22.04

  # 添加 Git 深度配置，确保能获取所有分支信息
  variables:
    GIT_DEPTH: 0  # 获取完整历史记录，包括所有分支

  before_script:
    - apt-get update
    - apt-get install -y git curl
    - git config --global user.email "ci@gitlab.iceymoss"
    - git config --global user.name "GitLab CI"
    # 获取所有分支信息，确保能访问 master 分支
    - git fetch --all
    - git config --global pull.rebase false  # 添加合并策略配置
  script:
    - |
      echo "开始更新配置..."
      
      # 步骤 1 => 
      if git show-ref --quiet refs/remotes/origin/k8s-config; then
        echo "k8s-config 分支已存在，检出并同步远程"
        # 创建本地分支并跟踪远程分支
        git checkout -B k8s-config origin/k8s-config
        # 使用合并策略拉取远程更改（允许合并冲突）
        git pull --no-rebase origin k8s-config || echo "拉取完成或存在冲突，继续执行"
      else
        echo "k8s-config 分支不存在，创建新分支"
        git checkout -b k8s-config origin/master
      fi
      
      # 步骤 2: 同步 master 分支的 k8s 目录
      echo "步骤 2 => 同步 master 分支的 k8s 目录"
      git fetch origin master
      git checkout origin/master -- k8s/ 
      
      # 步骤 3: 更新镜像标签
      echo "步骤 3 => 更新镜像标签"
      sed -i "s|image:.*hichat.*|image: $IMAGE_TAG_COMMIT|g" k8s/hichat.yaml
      echo "更新后的镜像配置:"
      grep "image:" k8s/hichat.yaml
      
      # 步骤 4: 提交更改
      echo "步骤 4 => 提交更改到配置分支"
      git add k8s/hichat.yaml
      
      # 检查是否有需要提交的更改
      if git diff-index --quiet HEAD --; then
        echo "没有检测到更改，跳过提交"
      else
        git commit -m "chore: update image to $CI_COMMIT_SHORT_SHA [skip ci]"
      
        # 步骤 5: 推送到配置分支（使用安全强制推送）
        echo "步骤 5 => 推送到配置分支"
        git push --force-with-lease http://${GITLAB_USERNAME}:${PERSONAL_ACCESS_TOKEN}@gitlab.iceymoss/root/hichat.git HEAD:k8s-config
      
        # 步骤 6: 输出完成信息
        echo "配置更新完成，已推送到 k8s-config 分支"
        echo "ArgoCD 将自动检测分支变化并同步部署到集群"
      fi
  only:
    - master
  when: on_success
  tags:
    - docker